# 工厂进化

## 0, NoFactory

假设工程中有多种配置文件: xml, properties, json, ymal...等, 我们的Parser解析器类, 需要根据不同的文件类别, 使用不同的解析方式.

本质: 对象的创建与对象的使用耦合在客户端代码中, 不符合单一职责原则, 并且, 当需求需要创建新类型的对象时, 只能改变使用对象的客户端, 不符合开闭原则.

### 0.1 使用示例

### 0.2 带来问题

​ 扩展问题, 单一职责问题

### 0.3 解决方式

​ 使用Spring这种大工厂或者自定义工厂, 解耦对象的创建与使用.

## 1, 简单工厂

### 1.1 使用示例

​ 方式1: 每次去找工厂返回一个新创建的对象

​ 方式2: 每次都获取同一个创建好的对象(单例方式创建好, 放到集合缓存中)

### 1.2 带来问题

未来添加更多的解析器对象, 需要修改工厂类, 添加新的if...else...没有解决扩展问题, 不符合开闭原则

​ 可以不使用if...else..., 可以放到map里面, 形成单例;

​ 但是和没有使用工厂模式一样, 也存在扩展问题, 每次扩展都需要修改源码, 不符合开闭原则

### 1.3 解决方式

​ 使用Spring

## 2, 工厂方法

本质: 一个产品对应一个工厂

### 2.1 使用示例

### 2.2 带来问题

在客户端使用对象的时候, 对象的创建和对象的使用确实解耦了;

但工厂的获取与客户端却耦合了

### 2.3 解决方式

使用Spring这个大工厂

## 3, 抽象工厂

本质: 工厂方法是一个特殊的抽象工厂,

抽象工厂的类和方法都是抽象的, 便于扩展, 需要哪一类对象组合, 就自定义抽象类的子类

工厂方法中的工厂类就创建一种确定的类, 并且仅仅创建一个; 抽象工厂的抽象方法有多个, 目的可以创建不同对象组合

### 3.1 使用示例

本质: 抽象的类, 抽象的方法; 继承的时候, 需要什么就创建什么

### 3.2 带来问题

一种对象或者一类对象就需要创建一个工厂类, 是不是有必要?

## 4, DI容器



