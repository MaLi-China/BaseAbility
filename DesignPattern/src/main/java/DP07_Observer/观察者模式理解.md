# 观察者模式

## 一, 解决的问题

在被观察者内部维护一个观察者集合, 在需要的动作发生之后, 调用所有观察者的动作

## 二, 本质

语法上: 维护了一个集合, 使用多态, 面向抽象编程, 调用所有观察者的统一动作 ​ 语义上: 被观察者主动的调用了观察者的方法, 解耦到另一个类中, 使有新的需求时候易于扩展

## 三, 代码模板

```Java
class 被观察者 {
    List<观察者> 观察者们 = new List<>();

    public 添加观察者(观察者);

    public 删除观察者(观察者);

    public 业务方法(观察者);        // 内部调用观察者的方法
}

interface 观察者 {
    doAction();                    // 观察者的多态方法
}

class 具体观察者 implements 观察者 {
    public void doAction() {
    }    // 具体的多态实现
}
```

## 四, 应用场景举例

注册之后的推广: 简单需求; 迭代需求; ​ Controller中通过Spring注入观察者们, 这样, 即使需求出现变化, ​ Controller类不需要任何修改, 就能满足不断迭代的需求

## 五, 观察者进阶

同进程内同步阻塞方式: 目的解耦 ​ 同进程内异步非阻塞方式: 使用线程池(目的解耦+提高执行效率)
​ 跨进程实现观察者方式1, 在调观察者动作的业务方法中发送RPC请求; ​ 跨进程实现观察者方式2, 发送消息给消息队列, 这种观察者解耦的更彻底, 压根不需要做的观察者有谁;

## 六, 思考问题

问题1: 请对比一下“生产者 - 消费者”模型和观察者模式的区别和联系。 ​ 前者属于观察者模式的一种, 引入了消息队列, 采用异步非阻塞的方式, ​ 一般生产者:消费者=n:n; ​ 后者不一定有消息队列, ​ 一般被观察者:
观察者=1:n ​ 问题2: 除了今天提到的观察者模式的几个应用场景， ​ 比如邮件订阅，你还能想到有哪些其他的应用场景吗？

## 七, 自定义实现一个观察者框架

### 作用

​ 1, 通过框架注册观察者, 注入各种类型的观察者, 并非一定要实现了指定接口;

​ 2, 触发指定的观察者 `post(Object event);`

